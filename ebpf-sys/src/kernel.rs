/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
pub type __u8 = ::std::os::raw::c_uchar;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __u32 = ::std::os::raw::c_uint;
pub type __u64 = ::std::os::raw::c_ulonglong;
pub type u8 = ::std::os::raw::c_uchar;
pub type s64 = ::std::os::raw::c_longlong;
pub type u64 = ::std::os::raw::c_ulonglong;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __be16 = __u16;
pub type __be32 = __u32;
pub type __wsum = __u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atomic_t {
    pub counter: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_atomic_t() {
    assert_eq!(
        ::std::mem::size_of::<atomic_t>(),
        4usize,
        concat!("Size of: ", stringify!(atomic_t))
    );
    assert_eq!(
        ::std::mem::align_of::<atomic_t>(),
        4usize,
        concat!("Alignment of ", stringify!(atomic_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atomic_t>())).counter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atomic_t),
            "::",
            stringify!(counter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_head {
    pub next: *mut list_head,
    pub prev: *mut list_head,
}
#[test]
fn bindgen_test_layout_list_head() {
    assert_eq!(
        ::std::mem::size_of::<list_head>(),
        16usize,
        concat!("Size of: ", stringify!(list_head))
    );
    assert_eq!(
        ::std::mem::align_of::<list_head>(),
        8usize,
        concat!("Alignment of ", stringify!(list_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<list_head>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_head),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<list_head>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(list_head),
            "::",
            stringify!(prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_regs {
    pub r15: ::std::os::raw::c_ulong,
    pub r14: ::std::os::raw::c_ulong,
    pub r13: ::std::os::raw::c_ulong,
    pub r12: ::std::os::raw::c_ulong,
    pub bp: ::std::os::raw::c_ulong,
    pub bx: ::std::os::raw::c_ulong,
    pub r11: ::std::os::raw::c_ulong,
    pub r10: ::std::os::raw::c_ulong,
    pub r9: ::std::os::raw::c_ulong,
    pub r8: ::std::os::raw::c_ulong,
    pub ax: ::std::os::raw::c_ulong,
    pub cx: ::std::os::raw::c_ulong,
    pub dx: ::std::os::raw::c_ulong,
    pub si: ::std::os::raw::c_ulong,
    pub di: ::std::os::raw::c_ulong,
    pub orig_ax: ::std::os::raw::c_ulong,
    pub ip: ::std::os::raw::c_ulong,
    pub cs: ::std::os::raw::c_ulong,
    pub flags: ::std::os::raw::c_ulong,
    pub sp: ::std::os::raw::c_ulong,
    pub ss: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_pt_regs() {
    assert_eq!(
        ::std::mem::size_of::<pt_regs>(),
        168usize,
        concat!("Size of: ", stringify!(pt_regs))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_regs>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_regs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r15 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r14 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r13 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r12 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).bp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(bp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).bx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(bx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r11 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r10 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r9 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r8 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).ax as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(ax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).cx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).dx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).si as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(si)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).di as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(di)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).orig_ax as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(orig_ax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).ip as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).cs as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).flags as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).sp as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).ss as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(ss)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qspinlock {
    pub val: atomic_t,
}
#[test]
fn bindgen_test_layout_qspinlock() {
    assert_eq!(
        ::std::mem::size_of::<qspinlock>(),
        4usize,
        concat!("Size of: ", stringify!(qspinlock))
    );
    assert_eq!(
        ::std::mem::align_of::<qspinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(qspinlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qspinlock>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock),
            "::",
            stringify!(val)
        )
    );
}
pub type arch_spinlock_t = qspinlock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raw_spinlock {
    pub raw_lock: arch_spinlock_t,
}
#[test]
fn bindgen_test_layout_raw_spinlock() {
    assert_eq!(
        ::std::mem::size_of::<raw_spinlock>(),
        4usize,
        concat!("Size of: ", stringify!(raw_spinlock))
    );
    assert_eq!(
        ::std::mem::align_of::<raw_spinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(raw_spinlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raw_spinlock>())).raw_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raw_spinlock),
            "::",
            stringify!(raw_lock)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spinlock {
    pub __bindgen_anon_1: spinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spinlock__bindgen_ty_1 {
    pub rlock: raw_spinlock,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_spinlock__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spinlock__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(spinlock__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spinlock__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(spinlock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spinlock__bindgen_ty_1>())).rlock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spinlock__bindgen_ty_1),
            "::",
            stringify!(rlock)
        )
    );
}
#[test]
fn bindgen_test_layout_spinlock() {
    assert_eq!(
        ::std::mem::size_of::<spinlock>(),
        4usize,
        concat!("Size of: ", stringify!(spinlock))
    );
    assert_eq!(
        ::std::mem::align_of::<spinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(spinlock))
    );
}
pub type spinlock_t = spinlock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_node {
    pub __rb_parent_color: ::std::os::raw::c_ulong,
    pub rb_right: *mut rb_node,
    pub rb_left: *mut rb_node,
}
#[test]
fn bindgen_test_layout_rb_node() {
    assert_eq!(
        ::std::mem::size_of::<rb_node>(),
        24usize,
        concat!("Size of: ", stringify!(rb_node))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_node>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rb_node>())).__rb_parent_color as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_node),
            "::",
            stringify!(__rb_parent_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rb_node>())).rb_right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_node),
            "::",
            stringify!(rb_right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rb_node>())).rb_left as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_node),
            "::",
            stringify!(rb_left)
        )
    );
}
#[doc = " refcount_t - variant of atomic_t specialized for reference counts"]
#[doc = " @refs: atomic_t counter field"]
#[doc = ""]
#[doc = " The counter saturates at UINT_MAX and will not move once"]
#[doc = " there. This avoids wrapping the counter and causing 'spurious'"]
#[doc = " use-after-free bugs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct refcount_struct {
    pub refs: atomic_t,
}
#[test]
fn bindgen_test_layout_refcount_struct() {
    assert_eq!(
        ::std::mem::size_of::<refcount_struct>(),
        4usize,
        concat!("Size of: ", stringify!(refcount_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<refcount_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(refcount_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<refcount_struct>())).refs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(refcount_struct),
            "::",
            stringify!(refs)
        )
    );
}
pub type refcount_t = refcount_struct;
pub type ktime_t = s64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct read_descriptor_t {
    pub written: usize,
    pub count: usize,
    pub arg: read_descriptor_t__bindgen_ty_1,
    pub error: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union read_descriptor_t__bindgen_ty_1 {
    pub buf: *mut ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_read_descriptor_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<read_descriptor_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(read_descriptor_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<read_descriptor_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(read_descriptor_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<read_descriptor_t__bindgen_ty_1>())).buf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(read_descriptor_t__bindgen_ty_1),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<read_descriptor_t__bindgen_ty_1>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(read_descriptor_t__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
}
#[test]
fn bindgen_test_layout_read_descriptor_t() {
    assert_eq!(
        ::std::mem::size_of::<read_descriptor_t>(),
        32usize,
        concat!("Size of: ", stringify!(read_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<read_descriptor_t>(),
        8usize,
        concat!("Alignment of ", stringify!(read_descriptor_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<read_descriptor_t>())).written as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(read_descriptor_t),
            "::",
            stringify!(written)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<read_descriptor_t>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(read_descriptor_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<read_descriptor_t>())).arg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(read_descriptor_t),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<read_descriptor_t>())).error as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(read_descriptor_t),
            "::",
            stringify!(error)
        )
    );
}
pub type sk_read_actor_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut read_descriptor_t,
        arg2: *mut sk_buff,
        arg3: ::std::os::raw::c_uint,
        arg4: usize,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock {
    _unused: [u8; 0],
}
#[doc = " csum_ipv6_magic - Compute checksum of an IPv6 pseudo header."]
#[doc = " @saddr: source address"]
#[doc = " @daddr: destination address"]
#[doc = " @len: length of packet"]
#[doc = " @proto: protocol of packet"]
#[doc = " @sum: initial sum (32bit unfolded) to be added in"]
#[doc = ""]
#[doc = " Computes an IPv6 pseudo header checksum. This sum is added the checksum"]
#[doc = " into UDP/TCP packets and contains some link layer information."]
#[doc = " Returns the unfolded 32bit checksum."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub u6_addr8: [__u8; 16usize],
    pub u6_addr16: [__be16; 8usize],
    pub u6_addr32: [__be32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).u6_addr8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(u6_addr8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).u6_addr16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(u6_addr16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).u6_addr32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(u6_addr32)
        )
    );
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr>())).in6_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(in6_u)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_bridge_info {
    pub use_: refcount_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub frag_max_size: __u16,
    pub physindev: *mut net_device,
    pub physoutdev: *mut net_device,
    pub __bindgen_anon_1: nf_bridge_info__bindgen_ty_2,
}
pub const nf_bridge_info_BRNF_PROTO_UNCHANGED: nf_bridge_info__bindgen_ty_1 = 0;
pub const nf_bridge_info_BRNF_PROTO_8021Q: nf_bridge_info__bindgen_ty_1 = 1;
pub const nf_bridge_info_BRNF_PROTO_PPPOE: nf_bridge_info__bindgen_ty_1 = 2;
pub type nf_bridge_info__bindgen_ty_1 = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union nf_bridge_info__bindgen_ty_2 {
    pub ipv4_daddr: __be32,
    pub ipv6_daddr: in6_addr,
    pub neigh_header: [::std::os::raw::c_char; 8usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_nf_bridge_info__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<nf_bridge_info__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(nf_bridge_info__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<nf_bridge_info__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(nf_bridge_info__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nf_bridge_info__bindgen_ty_2>())).ipv4_daddr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_bridge_info__bindgen_ty_2),
            "::",
            stringify!(ipv4_daddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nf_bridge_info__bindgen_ty_2>())).ipv6_daddr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_bridge_info__bindgen_ty_2),
            "::",
            stringify!(ipv6_daddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nf_bridge_info__bindgen_ty_2>())).neigh_header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_bridge_info__bindgen_ty_2),
            "::",
            stringify!(neigh_header)
        )
    );
}
#[test]
fn bindgen_test_layout_nf_bridge_info() {
    assert_eq!(
        ::std::mem::size_of::<nf_bridge_info>(),
        40usize,
        concat!("Size of: ", stringify!(nf_bridge_info))
    );
    assert_eq!(
        ::std::mem::align_of::<nf_bridge_info>(),
        8usize,
        concat!("Alignment of ", stringify!(nf_bridge_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nf_bridge_info>())).use_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_bridge_info),
            "::",
            stringify!(use_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nf_bridge_info>())).frag_max_size as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_bridge_info),
            "::",
            stringify!(frag_max_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nf_bridge_info>())).physindev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_bridge_info),
            "::",
            stringify!(physindev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nf_bridge_info>())).physoutdev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nf_bridge_info),
            "::",
            stringify!(physoutdev)
        )
    );
}
impl nf_bridge_info {
    #[inline]
    pub fn orig_proto(&self) -> nf_bridge_info__bindgen_ty_1 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_orig_proto(&mut self, val: nf_bridge_info__bindgen_ty_1) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn pkt_otherhost(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pkt_otherhost(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_prerouting(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_in_prerouting(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bridged_dnat(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bridged_dnat(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        orig_proto: nf_bridge_info__bindgen_ty_1,
        pkt_otherhost: u8,
        in_prerouting: u8,
        bridged_dnat: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let orig_proto: u32 = unsafe { ::std::mem::transmute(orig_proto) };
            orig_proto as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let pkt_otherhost: u8 = unsafe { ::std::mem::transmute(pkt_otherhost) };
            pkt_otherhost as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let in_prerouting: u8 = unsafe { ::std::mem::transmute(in_prerouting) };
            in_prerouting as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let bridged_dnat: u8 = unsafe { ::std::mem::transmute(bridged_dnat) };
            bridged_dnat as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_buff_head {
    pub next: *mut sk_buff,
    pub prev: *mut sk_buff,
    pub qlen: __u32,
    pub lock: spinlock_t,
}
#[test]
fn bindgen_test_layout_sk_buff_head() {
    assert_eq!(
        ::std::mem::size_of::<sk_buff_head>(),
        24usize,
        concat!("Size of: ", stringify!(sk_buff_head))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_buff_head>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_buff_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff_head>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff_head),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff_head>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff_head),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff_head>())).qlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff_head),
            "::",
            stringify!(qlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff_head>())).lock as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff_head),
            "::",
            stringify!(lock)
        )
    );
}
pub type sk_buff_data_t = ::std::os::raw::c_uint;
#[doc = "\tstruct sk_buff - socket buffer"]
#[doc = "\t@next: Next buffer in list"]
#[doc = "\t@prev: Previous buffer in list"]
#[doc = "\t@tstamp: Time we arrived/left"]
#[doc = "\t@rbnode: RB tree node, alternative to next/prev for netem/tcp"]
#[doc = "\t@sk: Socket we are owned by"]
#[doc = "\t@dev: Device we arrived on/are leaving by"]
#[doc = "\t@cb: Control buffer. Free for use by every layer. Put private vars here"]
#[doc = "\t@_skb_refdst: destination entry (with norefcount bit)"]
#[doc = "\t@sp: the security path, used for xfrm"]
#[doc = "\t@len: Length of actual data"]
#[doc = "\t@data_len: Data length"]
#[doc = "\t@mac_len: Length of link layer header"]
#[doc = "\t@hdr_len: writable header length of cloned skb"]
#[doc = "\t@csum: Checksum (must include start/offset pair)"]
#[doc = "\t@csum_start: Offset from skb->head where checksumming should start"]
#[doc = "\t@csum_offset: Offset from csum_start where checksum should be stored"]
#[doc = "\t@priority: Packet queueing priority"]
#[doc = "\t@ignore_df: allow local fragmentation"]
#[doc = "\t@cloned: Head may be cloned (check refcnt to be sure)"]
#[doc = "\t@ip_summed: Driver fed us an IP checksum"]
#[doc = "\t@nohdr: Payload reference only, must not modify header"]
#[doc = "\t@pkt_type: Packet class"]
#[doc = "\t@fclone: skbuff clone status"]
#[doc = "\t@ipvs_property: skbuff is owned by ipvs"]
#[doc = "\t@tc_skip_classify: do not classify packet. set by IFB device"]
#[doc = "\t@tc_at_ingress: used within tc_classify to distinguish in/egress"]
#[doc = "\t@tc_redirected: packet was redirected by a tc action"]
#[doc = "\t@tc_from_ingress: if tc_redirected, tc_at_ingress at time of redirect"]
#[doc = "\t@peeked: this packet has been seen already, so stats have been"]
#[doc = "\t\tdone for it, don't do them again"]
#[doc = "\t@nf_trace: netfilter packet trace flag"]
#[doc = "\t@protocol: Packet protocol from driver"]
#[doc = "\t@destructor: Destruct function"]
#[doc = "\t@tcp_tsorted_anchor: list structure for TCP (tp->tsorted_sent_queue)"]
#[doc = "\t@_nfct: Associated connection, if any (with nfctinfo bits)"]
#[doc = "\t@nf_bridge: Saved data about a bridged frame - see br_netfilter.c"]
#[doc = "\t@skb_iif: ifindex of device we arrived on"]
#[doc = "\t@tc_index: Traffic control index"]
#[doc = "\t@hash: the packet hash"]
#[doc = "\t@queue_mapping: Queue mapping for multiqueue devices"]
#[doc = "\t@xmit_more: More SKBs are pending for this queue"]
#[doc = "\t@pfmemalloc: skbuff was allocated from PFMEMALLOC reserves"]
#[doc = "\t@ndisc_nodetype: router type (from link layer)"]
#[doc = "\t@ooo_okay: allow the mapping of a socket to a queue to be changed"]
#[doc = "\t@l4_hash: indicate hash is a canonical 4-tuple hash over transport"]
#[doc = "\t\tports."]
#[doc = "\t@sw_hash: indicates hash was computed in software stack"]
#[doc = "\t@wifi_acked_valid: wifi_acked was set"]
#[doc = "\t@wifi_acked: whether frame was acked on wifi or not"]
#[doc = "\t@no_fcs:  Request NIC to treat last 4 bytes as Ethernet FCS"]
#[doc = "\t@csum_not_inet: use CRC32c to resolve CHECKSUM_PARTIAL"]
#[doc = "\t@dst_pending_confirm: need to confirm neighbour"]
#[doc = "\t@napi_id: id of the NAPI struct this skb came from"]
#[doc = "\t@secmark: security marking"]
#[doc = "\t@mark: Generic packet mark"]
#[doc = "\t@vlan_proto: vlan encapsulation protocol"]
#[doc = "\t@vlan_tci: vlan tag control information"]
#[doc = "\t@inner_protocol: Protocol (encapsulation)"]
#[doc = "\t@inner_transport_header: Inner transport layer header (encapsulation)"]
#[doc = "\t@inner_network_header: Network layer header (encapsulation)"]
#[doc = "\t@inner_mac_header: Link layer header (encapsulation)"]
#[doc = "\t@transport_header: Transport layer header"]
#[doc = "\t@network_header: Network layer header"]
#[doc = "\t@mac_header: Link layer header"]
#[doc = "\t@tail: Tail pointer"]
#[doc = "\t@end: End pointer"]
#[doc = "\t@head: Head of buffer"]
#[doc = "\t@data: Data head pointer"]
#[doc = "\t@truesize: Buffer size"]
#[doc = "\t@users: User count - see {datagram,tcp}.c"]
#[repr(C)]
pub struct sk_buff {
    pub __bindgen_anon_1: sk_buff__bindgen_ty_1,
    pub sk: *mut sock,
    pub __bindgen_anon_2: sk_buff__bindgen_ty_2,
    pub cb: [::std::os::raw::c_char; 48usize],
    pub __bindgen_anon_3: sk_buff__bindgen_ty_3,
    pub sp: *mut sec_path,
    pub _nfct: ::std::os::raw::c_ulong,
    pub nf_bridge: *mut nf_bridge_info,
    pub len: ::std::os::raw::c_uint,
    pub data_len: ::std::os::raw::c_uint,
    pub mac_len: __u16,
    pub hdr_len: __u16,
    pub queue_mapping: __u16,
    pub __cloned_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub headers_start: __IncompleteArrayField<__u32>,
    pub __pkt_type_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub tc_index: __u16,
    pub __bindgen_anon_4: sk_buff__bindgen_ty_4,
    pub priority: __u32,
    pub skb_iif: ::std::os::raw::c_int,
    pub hash: __u32,
    pub vlan_proto: __be16,
    pub vlan_tci: __u16,
    pub __bindgen_anon_5: sk_buff__bindgen_ty_5,
    pub secmark: __u32,
    pub __bindgen_anon_6: sk_buff__bindgen_ty_6,
    pub __bindgen_anon_7: sk_buff__bindgen_ty_7,
    pub inner_transport_header: __u16,
    pub inner_network_header: __u16,
    pub inner_mac_header: __u16,
    pub protocol: __be16,
    pub transport_header: __u16,
    pub network_header: __u16,
    pub mac_header: __u16,
    pub headers_end: __IncompleteArrayField<__u32>,
    pub tail: sk_buff_data_t,
    pub end: sk_buff_data_t,
    pub head: *mut ::std::os::raw::c_uchar,
    pub data: *mut ::std::os::raw::c_uchar,
    pub truesize: ::std::os::raw::c_uint,
    pub users: refcount_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_1 {
    pub __bindgen_anon_1: sk_buff__bindgen_ty_1__bindgen_ty_1,
    pub rbnode: rb_node,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_buff__bindgen_ty_1__bindgen_ty_1 {
    pub next: *mut sk_buff,
    pub prev: *mut sk_buff,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub dev: *mut net_device,
    pub dev_scratch: ::std::os::raw::c_ulong,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).dev
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()))
                .dev_scratch as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(dev_scratch)
        )
    );
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sk_buff__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_buff__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_buff__bindgen_ty_1__bindgen_ty_1>())).next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_buff__bindgen_ty_1__bindgen_ty_1>())).prev as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(prev)
        )
    );
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sk_buff__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_buff__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff__bindgen_ty_1>())).rbnode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_1),
            "::",
            stringify!(rbnode)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_2 {
    pub tstamp: ktime_t,
    pub skb_mstamp: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<sk_buff__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_buff__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff__bindgen_ty_2>())).tstamp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_2),
            "::",
            stringify!(tstamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_buff__bindgen_ty_2>())).skb_mstamp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_2),
            "::",
            stringify!(skb_mstamp)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_3 {
    pub __bindgen_anon_1: sk_buff__bindgen_ty_3__bindgen_ty_1,
    pub tcp_tsorted_anchor: list_head,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_buff__bindgen_ty_3__bindgen_ty_1 {
    pub _skb_refdst: ::std::os::raw::c_ulong,
    pub destructor: ::std::option::Option<unsafe extern "C" fn(skb: *mut sk_buff)>,
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sk_buff__bindgen_ty_3__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_3__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_buff__bindgen_ty_3__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sk_buff__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_buff__bindgen_ty_3__bindgen_ty_1>()))._skb_refdst as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(_skb_refdst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_buff__bindgen_ty_3__bindgen_ty_1>())).destructor as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(destructor)
        )
    );
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<sk_buff__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_buff__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_3))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_buff__bindgen_ty_3>())).tcp_tsorted_anchor as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_3),
            "::",
            stringify!(tcp_tsorted_anchor)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4 {
    pub csum: __wsum,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_4__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_buff__bindgen_ty_4__bindgen_ty_1 {
    pub csum_start: __u16,
    pub csum_offset: __u16,
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sk_buff__bindgen_ty_4__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_4__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_buff__bindgen_ty_4__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(sk_buff__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_buff__bindgen_ty_4__bindgen_ty_1>())).csum_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(csum_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_buff__bindgen_ty_4__bindgen_ty_1>())).csum_offset as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(csum_offset)
        )
    );
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<sk_buff__bindgen_ty_4>(),
        4usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_buff__bindgen_ty_4>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff__bindgen_ty_4>())).csum as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_4),
            "::",
            stringify!(csum)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_5 {
    pub napi_id: ::std::os::raw::c_uint,
    pub sender_cpu: ::std::os::raw::c_uint,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<sk_buff__bindgen_ty_5>(),
        4usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_buff__bindgen_ty_5>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_5))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff__bindgen_ty_5>())).napi_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_5),
            "::",
            stringify!(napi_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_buff__bindgen_ty_5>())).sender_cpu as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_5),
            "::",
            stringify!(sender_cpu)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_6 {
    pub mark: __u32,
    pub reserved_tailroom: __u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<sk_buff__bindgen_ty_6>(),
        4usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_buff__bindgen_ty_6>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff__bindgen_ty_6>())).mark as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_6),
            "::",
            stringify!(mark)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_buff__bindgen_ty_6>())).reserved_tailroom as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_6),
            "::",
            stringify!(reserved_tailroom)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_7 {
    pub inner_protocol: __be16,
    pub inner_ipproto: __u8,
    _bindgen_union_align: u16,
}
#[test]
fn bindgen_test_layout_sk_buff__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<sk_buff__bindgen_ty_7>(),
        2usize,
        concat!("Size of: ", stringify!(sk_buff__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_buff__bindgen_ty_7>(),
        2usize,
        concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_7))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_buff__bindgen_ty_7>())).inner_protocol as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_7),
            "::",
            stringify!(inner_protocol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sk_buff__bindgen_ty_7>())).inner_ipproto as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff__bindgen_ty_7),
            "::",
            stringify!(inner_ipproto)
        )
    );
}
#[test]
fn bindgen_test_layout_sk_buff() {
    assert_eq!(
        ::std::mem::size_of::<sk_buff>(),
        232usize,
        concat!("Size of: ", stringify!(sk_buff))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_buff>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_buff))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).sk as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(sk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).cb as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).sp as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>()))._nfct as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(_nfct)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).nf_bridge as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(nf_bridge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).len as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).data_len as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).mac_len as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(mac_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).hdr_len as *const _ as usize },
        138usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(hdr_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).queue_mapping as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(queue_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).__cloned_offset as *const _ as usize },
        142usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(__cloned_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).headers_start as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(headers_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).__pkt_type_offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(__pkt_type_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).tc_index as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(tc_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).priority as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).skb_iif as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(skb_iif)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).hash as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).vlan_proto as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(vlan_proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).vlan_tci as *const _ as usize },
        170usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(vlan_tci)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).secmark as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(secmark)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).inner_transport_header as *const _ as usize },
        186usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(inner_transport_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).inner_network_header as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(inner_network_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).inner_mac_header as *const _ as usize },
        190usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(inner_mac_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).protocol as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).transport_header as *const _ as usize },
        194usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(transport_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).network_header as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(network_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).mac_header as *const _ as usize },
        198usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(mac_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).headers_end as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(headers_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).tail as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).end as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).head as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).data as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).truesize as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(truesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff>())).users as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff),
            "::",
            stringify!(users)
        )
    );
}
impl sk_buff {
    #[inline]
    pub fn cloned(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cloned(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nohdr(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nohdr(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fclone(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_fclone(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn peeked(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_peeked(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn head_frag(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_head_frag(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xmit_more(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_xmit_more(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pfmemalloc(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pfmemalloc(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cloned: __u8,
        nohdr: __u8,
        fclone: __u8,
        peeked: __u8,
        head_frag: __u8,
        xmit_more: __u8,
        pfmemalloc: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cloned: u8 = unsafe { ::std::mem::transmute(cloned) };
            cloned as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let nohdr: u8 = unsafe { ::std::mem::transmute(nohdr) };
            nohdr as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let fclone: u8 = unsafe { ::std::mem::transmute(fclone) };
            fclone as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let peeked: u8 = unsafe { ::std::mem::transmute(peeked) };
            peeked as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let head_frag: u8 = unsafe { ::std::mem::transmute(head_frag) };
            head_frag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let xmit_more: u8 = unsafe { ::std::mem::transmute(xmit_more) };
            xmit_more as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let pfmemalloc: u8 = unsafe { ::std::mem::transmute(pfmemalloc) };
            pfmemalloc as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn pkt_type(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_pkt_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_df(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ignore_df(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nf_trace(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nf_trace(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ip_summed(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ip_summed(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ooo_okay(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ooo_okay(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_hash(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_l4_hash(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_hash(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sw_hash(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_acked_valid(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wifi_acked_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_acked(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wifi_acked(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_fcs(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_fcs(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encapsulation(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encapsulation(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encap_hdr_csum(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encap_hdr_csum(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_valid(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_complete_sw(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_complete_sw(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_level(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(17usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_csum_level(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_not_inet(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_not_inet(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_pending_confirm(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dst_pending_confirm(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ndisc_nodetype(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(21usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ndisc_nodetype(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(21usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ipvs_property(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ipvs_property(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inner_protocol_type(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inner_protocol_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn remcsum_offload(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_remcsum_offload(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offload_fwd_mark(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(26usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offload_fwd_mark(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offload_mr_fwd_mark(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(27usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offload_mr_fwd_mark(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tc_skip_classify(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(28usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tc_skip_classify(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tc_at_ingress(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(29usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tc_at_ingress(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tc_redirected(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(30usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tc_redirected(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tc_from_ingress(&self) -> __u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tc_from_ingress(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        pkt_type: __u8,
        ignore_df: __u8,
        nf_trace: __u8,
        ip_summed: __u8,
        ooo_okay: __u8,
        l4_hash: __u8,
        sw_hash: __u8,
        wifi_acked_valid: __u8,
        wifi_acked: __u8,
        no_fcs: __u8,
        encapsulation: __u8,
        encap_hdr_csum: __u8,
        csum_valid: __u8,
        csum_complete_sw: __u8,
        csum_level: __u8,
        csum_not_inet: __u8,
        dst_pending_confirm: __u8,
        ndisc_nodetype: __u8,
        ipvs_property: __u8,
        inner_protocol_type: __u8,
        remcsum_offload: __u8,
        offload_fwd_mark: __u8,
        offload_mr_fwd_mark: __u8,
        tc_skip_classify: __u8,
        tc_at_ingress: __u8,
        tc_redirected: __u8,
        tc_from_ingress: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let pkt_type: u8 = unsafe { ::std::mem::transmute(pkt_type) };
            pkt_type as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ignore_df: u8 = unsafe { ::std::mem::transmute(ignore_df) };
            ignore_df as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let nf_trace: u8 = unsafe { ::std::mem::transmute(nf_trace) };
            nf_trace as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let ip_summed: u8 = unsafe { ::std::mem::transmute(ip_summed) };
            ip_summed as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ooo_okay: u8 = unsafe { ::std::mem::transmute(ooo_okay) };
            ooo_okay as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let l4_hash: u8 = unsafe { ::std::mem::transmute(l4_hash) };
            l4_hash as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sw_hash: u8 = unsafe { ::std::mem::transmute(sw_hash) };
            sw_hash as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wifi_acked_valid: u8 = unsafe { ::std::mem::transmute(wifi_acked_valid) };
            wifi_acked_valid as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let wifi_acked: u8 = unsafe { ::std::mem::transmute(wifi_acked) };
            wifi_acked as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let no_fcs: u8 = unsafe { ::std::mem::transmute(no_fcs) };
            no_fcs as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let encapsulation: u8 = unsafe { ::std::mem::transmute(encapsulation) };
            encapsulation as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let encap_hdr_csum: u8 = unsafe { ::std::mem::transmute(encap_hdr_csum) };
            encap_hdr_csum as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let csum_valid: u8 = unsafe { ::std::mem::transmute(csum_valid) };
            csum_valid as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let csum_complete_sw: u8 = unsafe { ::std::mem::transmute(csum_complete_sw) };
            csum_complete_sw as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let csum_level: u8 = unsafe { ::std::mem::transmute(csum_level) };
            csum_level as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let csum_not_inet: u8 = unsafe { ::std::mem::transmute(csum_not_inet) };
            csum_not_inet as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let dst_pending_confirm: u8 = unsafe { ::std::mem::transmute(dst_pending_confirm) };
            dst_pending_confirm as u64
        });
        __bindgen_bitfield_unit.set(21usize, 2u8, {
            let ndisc_nodetype: u8 = unsafe { ::std::mem::transmute(ndisc_nodetype) };
            ndisc_nodetype as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let ipvs_property: u8 = unsafe { ::std::mem::transmute(ipvs_property) };
            ipvs_property as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let inner_protocol_type: u8 = unsafe { ::std::mem::transmute(inner_protocol_type) };
            inner_protocol_type as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let remcsum_offload: u8 = unsafe { ::std::mem::transmute(remcsum_offload) };
            remcsum_offload as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let offload_fwd_mark: u8 = unsafe { ::std::mem::transmute(offload_fwd_mark) };
            offload_fwd_mark as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let offload_mr_fwd_mark: u8 = unsafe { ::std::mem::transmute(offload_mr_fwd_mark) };
            offload_mr_fwd_mark as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let tc_skip_classify: u8 = unsafe { ::std::mem::transmute(tc_skip_classify) };
            tc_skip_classify as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let tc_at_ingress: u8 = unsafe { ::std::mem::transmute(tc_at_ingress) };
            tc_at_ingress as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let tc_redirected: u8 = unsafe { ::std::mem::transmute(tc_redirected) };
            tc_redirected as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let tc_from_ingress: u8 = unsafe { ::std::mem::transmute(tc_from_ingress) };
            tc_from_ingress as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct sk_buff_fclones {
    pub skb1: sk_buff,
    pub skb2: sk_buff,
    pub fclone_ref: refcount_t,
}
#[test]
fn bindgen_test_layout_sk_buff_fclones() {
    assert_eq!(
        ::std::mem::size_of::<sk_buff_fclones>(),
        472usize,
        concat!("Size of: ", stringify!(sk_buff_fclones))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_buff_fclones>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_buff_fclones))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff_fclones>())).skb1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff_fclones),
            "::",
            stringify!(skb1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff_fclones>())).skb2 as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff_fclones),
            "::",
            stringify!(skb2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sk_buff_fclones>())).fclone_ref as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_buff_fclones),
            "::",
            stringify!(fclone_ref)
        )
    );
}
pub type bpf_user_pt_regs_t = pt_regs;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_perf_event_data {
    pub regs: bpf_user_pt_regs_t,
    pub sample_period: __u64,
}
#[test]
fn bindgen_test_layout_bpf_perf_event_data() {
    assert_eq!(
        ::std::mem::size_of::<bpf_perf_event_data>(),
        176usize,
        concat!("Size of: ", stringify!(bpf_perf_event_data))
    );
    assert_eq!(
        ::std::mem::align_of::<bpf_perf_event_data>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_perf_event_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bpf_perf_event_data>())).regs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_perf_event_data),
            "::",
            stringify!(regs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<bpf_perf_event_data>())).sample_period as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_perf_event_data),
            "::",
            stringify!(sample_period)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sec_path {
    pub _address: u8,
}
